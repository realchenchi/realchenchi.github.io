<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>分布式 on 马野先生</title>
    <link>https://maye.netlify.app/tags/%E5%88%86%E5%B8%83%E5%BC%8F/</link>
    <description>Recent content in 分布式 on 马野先生</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 23 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://maye.netlify.app/tags/%E5%88%86%E5%B8%83%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>服务端高并发分布式架构演进之路</title>
      <link>https://maye.netlify.app/post/2020-10-23-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%AB%98%E5%B9%B6%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/</link>
      <pubDate>Fri, 23 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://maye.netlify.app/post/2020-10-23-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%AB%98%E5%B9%B6%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/</guid>
      <description>本文由 简悦 SimpRead 转码， 原文地址 segmentfault.com
  概述   本文以淘宝作为例子，介绍从一百个到千万级并发情况下服务端的架构的演进过程，同时列举出每个演进阶段会遇到的相关技术，让大家对架构的演进有一个整体的认知，文章最后汇总了一些架构设计的原则。
 特别说明：本文以淘宝为例仅仅是为了便于说明演进过程可能遇到的问题，并非是淘宝真正的技术演进路径
 基本概念   在介绍架构之前，为了避免部分读者对架构设计中的一些概念不了解，下面对几个最基础的概念进行介绍：
 分布式
系统中的多个模块在不同服务器上部署，即可称为分布式系统，如 Tomcat 和数据库分别部署在不同的服务器上，或两个相同功能的 Tomcat 分别部署在不同服务器上 高可用
系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性 集群
一个特定领域的软件部署在多台服务器上并作为一个整体提供一类服务，这个整体称为集群。如 Zookeeper 中的 Master 和 Slave 分别部署在多台服务器上，共同组成一个整体提供集中配置服务。在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动的接替它继续提供服务，这时候说明集群具有高可用性 负载均衡
请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的 正向代理和反向代理
系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理；当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。  架构演进   3.1 单机架构 以淘宝作为例子。在网站最初时，应用数量与用户数都较少，可以把 Tomcat 和数据库部署在同一台服务器上。浏览器往 www.taobao.com 发起请求时，首先经过 DNS 服务器（域名系统）把域名转换为实际 IP 地址 10.102.4.1，浏览器转而访问该 IP 对应的 Tomcat。
 随着用户数的增长，Tomcat 和数据库之间竞争资源，单机性能不足以支撑业务
 3.2 第一次演进：Tomcat 与数据库分开部署 Tomcat 和数据库分别独占服务器资源，显著提高两者各自性能。
 随着用户数的增长，并发读写数据库成为瓶颈</description>
    </item>
    
    <item>
      <title>百亿级微信红包的高并发资金交易系统设计方案</title>
      <link>https://maye.netlify.app/post/2020-05-19-%E7%99%BE%E4%BA%BF%E7%BA%A7%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E8%B5%84%E9%87%91%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/</link>
      <pubDate>Tue, 19 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://maye.netlify.app/post/2020-05-19-%E7%99%BE%E4%BA%BF%E7%BA%A7%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E8%B5%84%E9%87%91%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/</guid>
      <description>本文由 简悦 SimpRead 转码， 原文地址 https://www.infoq.cn/article/2017hongbao-weixin
 2017 年 1 月 28 日，正月初一，微信公布了用户在除夕当天收发微信红包的数量——142 亿个，而其收发峰值也已达到 76 万每秒。百亿级别的红包，如何保障并发性能与资金安全？这给微信带来了超级挑战。面对挑战，微信红包在分析了业界 “秒杀” 系统解决方案的基础上，采用了 SET 化、请求排队串行化、双维度分库表等设计，形成了独特的高并发、资金安全系统解决方案。实践证明，该方案表现稳定，且实现了除夕夜系统零故障运行。
本文将为读者介绍百亿级别红包背后的系统高并发设计方案，包括微信红包的两大业务特点、微信红包系统的技术难点、解决高并发问题通常使用的方案，以及微信红包系统的高并发解决方案。
一、微信红包的两大业务特点 微信红包（尤其是发在微信群里的红包，即群红包）业务形态上很类似网上的普通商品 “秒杀” 活动。
用户在微信群里发一个红包，等同于是普通商品 “秒杀” 活动的商品上架；微信群里的所有用户抢红包的动作，等同于 “秒杀” 活动中的查询库存；用户抢到红包后拆红包的动作，则对应 “秒杀” 活动中用户的 “秒杀” 动作。
不过除了上面的相同点之外，微信红包在业务形态上与普通商品 “秒杀” 活动相比，还具备自身的特点：
首先，微信红包业务比普通商品 “秒杀” 有更海量的并发要求。
微信红包用户在微信群里发一个红包，等同于在网上发布一次商品 “秒杀” 活动。假设同一时间有 10 万个群里的用户同时在发红包，那就相当于同一时间有 10 万个 “秒杀” 活动发布出去。10 万个微信群里的用户同时抢红包，将产生海量的并发请求。
其次，微信红包业务要求更严格的安全级别。
微信红包业务本质上是资金交易。微信红包是微信支付的一个商户，提供资金流转服务。
用户发红包时，相当于在微信红包这个商户上使用微信支付购买一笔 “钱”，并且收货地址是微信群。当用户支付成功后，红包“发货” 到微信群里，群里的用户拆开红包后，微信红包提供了将 “钱” 转入折红包用户微信零钱的服务。
资金交易业务比普通商品 “秒杀” 活动有更高的安全级别要求。普通的商品 “秒杀” 商品由商户提供，库存是商户预设的，“秒杀”时可以允许存在“超卖”（即实际被抢的商品数量比计划的库存多）、“少卖”（即实际被抢的商户数量比计划的库存少）的情况。但是对于微信红包，用户发 100 元的红包绝对不可以被拆出 101 元；用户发 100 元只被领取 99 元时，剩下的 1 元在 24 小时过期后要精确地退还给发红包用户，不能多也不能少。</description>
    </item>
    
  </channel>
</rss>
